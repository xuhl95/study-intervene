### myisam与innodb区别

1、 innodb支持事务，myisam不支持，对于innodb每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务

2、 innodb支持外键，而myisam不支持。对一个包含外键的innodb表转为myisam会失败

3、 innodb是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大

 myisam是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的
 
 也就是说：innodb的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而myisam的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针
 
4、innodb中不保存表的 具体行数，也就是说，执行select count() from table时，innodb要扫描一遍整个表来计算有多少行，但是myisam只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的

那么为什么innodb没有了这个变量呢？

    因为innodb的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。innodb会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，innodb还会尝试去遍历其他聚簇索引。
    如果索引并没有完全处于innodb维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS

5、 innodb不支持全文索引，而myisam支持全文索引，在涉及全文索引领域的查询效率上myisam速度更快高；PS：5.7以后的innodb支持全文索引了

6、myisam表格可以被压缩后进行查询操作

7、innodb支持表、行(默认)级锁，而myisam支持表级锁


innodb的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

8、innodb表必须有主键（用户没有指定的话会自己找或生产一个主键），而myisam可以没有

9、innodb存储文件有frm、ibd，而myisam是frm、MYD、MYI
> innodb：frm是表定义文件，ibd是数据文件

> myisam：frm是表定义文件，myd是数据文件，myi是索引文件


#### myisam与innodb如何选择

1、适用场景

myisam适合：(1)做很多count 的计算；(2)插入不频繁，查询非常频繁；(3)没有事务。

innodb适合：(1)可靠性要求比较高，或者要求事务；(2)表更新和查询都相当的频繁，并且表锁定的机会比较大的情况。

2、如何选择

MYISAM和INNODB是mysql数据库提供的两种存储引擎。两者的优劣可谓是各有千秋。INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MYISAM不支持。MYISAM的性能更优，占用的存储空间少。所以，选择何种存储引擎，视具体应用而定。

如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。

如果你的应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MYISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。

#### innodb为什么推荐使用自增ID作为主键
自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差

 [InnoDB表为什么要建议用自增列做主键](https://blog.csdn.net/wukong_666/article/details/54982712)